;; Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
;; Triangle 	  	T_(n)=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
;; Pentagonal 	  	P_(n)=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
;; Hexagonal 	  	H_(n)=n(2n−1) 	  	1, 6, 15, 28, 45, ...

;; It can be verified that T_(285) = P_(165) = H_(143) = 40755.

;; Find the next triangle number that is also pentagonal and hexagonal.

(defun p45 ()
  "find the first triangular, pentagonal, hexagonal number after 40755"
  (do ((a (1+ (hexagon-p 40755)) (1+ a)))
      (())
    (let ((hex (hexagon a)))
      (if (and (triangle-p hex)
	       (pentagon-p hex))
	  (return-from p45 hex)))))

;; raw search is wrong, and triangle-p has no memory
;; this is almost as perverse, and should stop the innermost two loops
;; on 
(defun p45a ()
  (let ((jmem 0)
	(results ())
	(kmem 0))
    (let ((triangles (make-array '(1000000) :element-type 'number)))
      (do ((index 0 (1+ index)))
	  ((= index 1000000))
	(setf (aref triangles index) (triangle (1+ index))))
      (format t "Triangles Complete~%")
      (let ((pentagons (make-array '(1000000) :element-type 'number)))
	(do ((index 0 (1+ index)))
	    ((= index 1000000))
	  (setf (aref pentagons index) (pentagon (1+ index))))
	(format t "Pentagons Complete~%")
	(let ((hexagons (make-array '(1000000) :element-type 'number)))
	  (do ((index 0 (1+ index)))
	      ((= index 1000000))
	    (setf (aref hexagons index) (hexagon (1+ index))))
	  (format t "Hexagons Complete")
	  (do ((hexindex 0 (1+ hexindex)))
	      ((= hexindex 1000000))
	    (do ((pentindex jmem (1+ pentindex)))
		((= pentindex 1000000))
	      (if (= (aref hexagons hexindex) (aref pentagons pentindex))
		  (do ((triangle-index kmem (1+ triangle-index)))
		      ((= triangle-index 1000000))
		    (if (= (aref triangles triangle-index)
			   (aref hexagons hexindex))
			(progn (push (aref hexagons hexindex) results)
			       (setf kmem triangle-index)
			       (setf triangle-index 999999)
			       (setf jmem pentindex)
			       (setf pentindex 999999)
			       (print (aref hexagons hexindex)))))))))))
  results))

(defun triangle (n)
  (/ (* (1+ n) n) 2))

(defun pentagon (n)
  (/ (* (- (* n 3) 1) n) 2))

(defun hexagon (n)
  (* n (1- (* n 2))))

;; what a horrible thing to do!
(defun triangle-p (n)
  (do* ((index 1 (1+ index))
       (triangle-index (triangle index) (triangle index)))
       ((> triangle-index n))
    (if (= triangle-index n)
	(return-from triangle-p index)))
  nil)

;; and yet you never learn...
(defun pentagon-p (n)
  (do* ((index 1 (1+ index))
	(pentagon-index (pentagon index) (pentagon index)))
       ((> pentagon-index n))
    (if (= pentagon-index n)
	(return-from pentagon-p index)))
  nil)

;; and to just keep on doing it? Shame on you!
(defun hexagon-p (n)
  (do* ((index 1 (1+ index))
	(hexagon-index (hexagon index) (hexagon index)))
       ((> hexagon-index n))
    (if (= hexagon-index n)
	(return-from hexagon-p index)))
  nil)
