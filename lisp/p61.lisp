#|
Problem 61
16 January 2004

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

    The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
    Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
    This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

|#

(defun triangle (n)
  (/ (* n (1+ n)) 2))

(defun is-triangle (n)
  (loop for i from 1 to (isqrt (* 2 n))
       when (= n (triangle i)) return t))

(defun suitable-triangles ()
  (remove-if (lambda (x) (< x 1000))
  (loop for i from 1
       for tri = (triangle i)
       while (< tri 10000)
       collect tri)))

(defun upper (n)
  (floor (/ n 100)))
(defun lower (n)
  (mod n 100))

(defun uppers (list)
  (mapcar #'upper list))

(defun lowers (list)
  (mapcar #'lower list))

(defun suitable-squares ()
  (remove-if (lambda (x) (< x 1000))
	     (loop for i from 1 to (isqrt 9999)
		collect (square i))))

(defun pentagon (n)
  (/ (* n (1- (* 3 n))) 2))

(defun is-pentagon (n)
  (loop for i from 1 to (isqrt (* 2 n))
       when (= n (pentagon i)) return t))

(defun suitable-pentagons ()
  (remove-if (lambda (x) (< x 1000))
	     (loop for i from 1 
		  for pen = (pentagon i)
		  while (< pen 10000)
		  collect pen)))

(defun hexagon (n)
  (* n (1- (* 2 n))))

(defun suitable-hexagons ()
  (remove-if (lambda (x) (< x 1000))
	     (loop for i from 1
		  for hex = (hexagon i)
		  while (< hex 10000)
		  collect hex)))


(defun heptagon (n)
  (/ (* n (- (* n 5) 3)) 2))

(defun suitable-heptagons ()
  (remove-if (lambda (x) (< x 1000))
	     (loop for i from 1
		  for hep = (heptagon i)
		  while (< hep 10000)
		  collect hep)))

(defun octagon (n)
  (* n (- (* 3 n) 2)))

(defun suitable-octagons ()
  (remove-if (lambda (x) (< x 1000))
	     (loop for i from 1
		  for oct = (octagon i)
		  while (< oct 10000)
		  collect oct)))

(defun cyclic? (set)
  "only for four digit numbers"
  (let ((firsts (uppers set))
	(seconds* (lowers set)))
    ;; rotate the values
    (let ((seconds (cons (last1 seconds*) (butlast seconds*))))
      (every #'= firsts seconds))))

(defun permutations (set)
  "rearrange elements of set in every possible way"
  (cond 
	((= (length set) 1) set)
	((= (length set) 2) (list (list (first set) (second set)) (list (second set) (first set))))
	(t (mapcar #'ensure-proper-list 
		   (loop for i in set append
			(mapcar (lambda (list) (cons i list)) 
				(permutations (remove i set))))))))

(defun ensure-proper-list (list)
  (cond ((null (cdr (last list))) list)
	(t (let ((result (butlast list)))
	     (append result (list (car (last list)) (cdr (last list))))))))
	   

(defun cyclify (set)
  "try to make a cyclic set from set"
  ;; don't permute unless we can find a set i.e. every upper is a lower
  (when (= (length set) (length (union (uppers set) (lowers set))))
    (find-if #'cyclic? (permutations set))))

(defun cycle-possible (n uppers lowers)
  (and (member (upper n) lowers)
       (member (lower n) uppers)))

(defun p61 ()
  (let* ((triangles (suitable-triangles))
	 (squares (suitable-squares))
	 (pentagons (suitable-pentagons))
	 (hexagons (suitable-hexagons))
	 (heptagons (suitable-heptagons))
	 (octagons (suitable-octagons))
	 (sq-uppers (uppers squares))
	 (sq-lowers (lowers squares))
	 (pen-uppers (uppers pentagons))
	 (pen-lowers (lowers pentagons))
	 (hex-uppers (uppers hexagons))
	 (hex-lowers (lowers hexagons))
	 (hep-uppers (uppers heptagons))
	 (hep-lowers (lowers heptagons))
	 (oct-uppers (uppers octagons))
	 (oct-lowers (lowers octagons)))
    (loop for oct in octagons 
       for oct+ in oct-uppers
       for oct- in oct-lowers
       do
	 (progn 
	   (format t "~a ~%" oct)
	   (loop for hep in heptagons
	      for hep+ in hep-uppers
	      for hep- in hep-lowers
	      for up7 = (list hep+ oct+)
	      for low7 = (list hep- oct-)
	      do
		(loop for hex in hexagons
		   for hex+ in hex-uppers
		   for hex- in hex-lowers
		   for up6 = (cons hex+ up7)
		   for low6 = (cons hex- low7)
		   do
		     (loop for pen in pentagons
			for pen+ in pen-uppers
			for pen- in pen-lowers
			for up5 = (cons pen+ up6)
			for low5 = (cons pen- low6)
			do
			  (loop for sqr in squares 
			       for sq+ in sq-uppers
			       for sq- in sq-lowers
			       for up4 = (cons sq+ up5)
			       for low4 = (cons sq- low5)
			       when (and 
				     (or (member sq+ low5)
					 (member sq- up5))
				      (= 4 (length (intersection up4 low4))))
				 do 
				 (loop for tri in triangles
				      for cycle = (cyclify (list tri sqr pen hex hep oct))
				      when cycle
				      do (return-from p61 (values (apply #'+ cycle) cycle)))))))))))
