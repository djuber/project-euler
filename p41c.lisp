(defun euler041 ()
  (let ((primes (array-sieve (isqrt 10000000))))
    (largest-n-digit-pandigital-prime 7 primes)))
 
(defun largest-n-digit-pandigital-prime (n primes-array
                                         &aux (n+1 (1+ n)) (n-1 (1- n)))
  (labels ((n-digits->number (von)
             (iterate loop ((i 0)
                            (acc 0))
               (if (< i n)
                   (loop (1+ i) (+ (aref von i) (* 10 acc)))
                   acc)))
           (co-lex (von)
             (map `(simple-vector ,n) #'(lambda (d) (- n+1 d)) von))
           (primep (n)
             (if (= n 2)
                 t
                 (dotimes (i (array-dimension primes-array 0) t)
                   (let ((k (aref primes-array i)))
                     (if (and k (zerop (mod n k)))
                         (return-from primep nil)))))))
    (let ((range (make-array n)))
      (dotimes (i n) (setf (aref range i) (1+ i)))
      (do ((perm range (perm-lex-successor n perm)))
          ((null perm) nil)
        (let ((digits (co-lex perm)))
          (unless (or (evenp (aref digits n-1)) (= (aref digits n-1) 5))
            (let ((p (n-digits->number digits)))
              (if (primep p)
                  (return-from largest-n-digit-pandigital-prime p)))))))))
 
(defun perm-lex-successor (n perm)
  (let ((res (make-array (1+ n) :initial-element 0)))
    (dotimes (i n) (setf (aref res (1+ i)) (aref perm i)))
    (iterate loop1 ((i (1- n)))
      (cond ((< (aref res (1+ i)) (aref res i))
             (loop1 (1- i)))
            ((zerop i)
             (return-from perm-lex-successor nil))
            (:else
             (iterate loop2 ((j n))
               (if (< (aref res j) (aref res i))
                   (loop2 (1- j))
                   (rotatef (aref res j) (aref res i))))
             (setf (subseq res (1+ i)) (nreverse (subseq res (1+ i)))))))
    (subseq res 1)))
 
(defun array-sieve (n)
 
  (if (< n 3)
      (return-from array-sieve nil))
  (let ((s-size (- (ceiling n 2) 1))
        (isqrtn (isqrt n)))
    (let ((s (let ((v (make-array s-size)))
               (dotimes (i s-size) (setf (aref v i) (+ 3 (* 2 i)))) v)))
      (labels ((cross-out (i)
                 (let ((step (aref s i)))
                   (do ((j (+ 3 (ash (* i (+ i 3)) 1)) (+ j step)))
                       ((>= j s-size))
                     (setf (aref s j) nil))))
               (next-i (i)
                 (do ((j (+ i 1) (+ j 1)))
                     ((aref s j) j))))
        (do ((i 0 (next-i i)))
            ((> (aref s i) isqrtn) s)
          (cross-out i))))))