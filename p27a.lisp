#|
27 Jun 2007 04:34 am 
wtwood
LISP 
USA	
  
CMU Common Lisp, compiled. I also noticed that b had to be a prime as well as the fact that the n = 1 case implies that a had to be at least 1 - b. I used an array of odd integers with the composites replaced by nil for the primes; it's way better for random access than a list! Time is about 105 milliseconds, about 4 of which was spent building the primes array.
|#


(defun euler027 ()
  (generate-and-test (array-sieve 100000)))

(defun generate-and-test (primes-array)
  "For each prime b less than 100 and each integer between 1-b and
   999 inclusive, determine the length of the longest sequence of primes
   generated by values of the expression n^2+A*n+B for n = 0, 1, ... .
   The length of the longest sequence, together with the a and b with
   which it was generated, is returned."
  (iterate loop-for-b ((b 2)
                       (bidx -1)
                       (best-a&b nil)
                       (bsf -1))
    (iterate loop-for-a ((a (- 1 b))
                         (best-a&b-for-this-a nil)
                         (best-for-this-a 0))
      (if (> a 999)
          (iterate next-b ((i (1+ bidx)))
            (if (> i 498)
                (if (> best-for-this-a bsf)
                    (list best-for-this-a best-a&b-for-this-a)
                    (list bsf best-a&b))
                (let ((p (aref primes-array i)))
                  (if p
                      (if (> best-for-this-a bsf)
                          (loop-for-b p i best-a&b-for-this-a best-for-this-a)
                          (loop-for-b p i best-a&b bsf))
                      (next-b (1+ i))))))
          (let ((psl (prime-sequence-length primes-array a b)))
            (if (> psl best-for-this-a)
                (loop-for-a (1+ a) (cons a b) psl)
                (loop-for-a (1+ a) best-a&b-for-this-a best-for-this-a)))))))

(defun prime-sequence-length (primes-array a b)
  "return the length of the longest sequence of primes generated by
   values of the expression n^2+A*n+B for n = 0, 1, ... .
     Primeness is checked by lookup in the array PRIMES-ARRAY."
  (let ((bound (array-dimension primes-array 0)))
    (iterate loop ((n 1)
                   (num 1)
                   (pv b))
      (let* ((v (+ pv a n n -1))
             (idx (ash (- v 3) -1)))
        (unless (< idx bound)
          (error "Not enough primes!"))
        (cond ((< v 2) num)
              ((= v 2)
               (loop (1+ n) (1+ num) v))
              ((aref primes-array idx)
               (loop (1+ n) (1+ num) v))
              (:else num))))))

